# Tutorial pentru cursul de Sisteme de Operare     

In prezent se constata tendinta de apropiere a performantelor microcalculatoarelor de cele ale calculatoarelor superioare lor, in paralel cu tendinta de apropiere a performantelor sistemelor de operare pentru sisteme de calcul mari de cele ale sistemelor de operare pentru mini sau microcalculatoare.   

Din punctul de vedere al dezvoltarii sistemului de operare, tendinta actuala este de dezvoltare a sistemelor de operare portabile. O alta directie este dezvoltarea de familii de sisteme de operare in care au fost dezvoltate sisteme de operare interactive, multitasking, asigurand si functiile pentru lucrul in retea de calculatoare; intre aceste sisteme de operare, unele sunt specializate pentru un anumit mod de utilizare.   
Sistemul de operare este o parte esentiala a oricarui sistem computational. Similar, cunostinte legate de sistemele de operare sunt esentiale pentru o buna educatie in domeniul informaticii.    

Cu toate ca informatica cunoaste o dezvoltare foarte rapida, precum si o multitudine de schimbari, cu o raspandire foarte larga de la jocuri pentru copii, pana la cele mai sofisticate programe de planificare destinate guvernelor si firmelor multinationale, conceptele fundamentale ale sistemelor de operare raman clare. Pe aceste concepte clare se bazeaza  si aceasta aplicatie. Aplicatia reprezinta un pachet solid de informatii, destinat studentilor, pentru o buna cunoastere si intelegere a sistemelor de operare.   

Accentul nu este pus pe sisteme de operare particulare sau pe componente hardware particulare. In schimb, se prezinta concepte fundamentale care se aplica pe o larga varietate de sisteme. Conceptele si principiile descrise aici se pot regasi in implementarile multor sisteme de operare incluzand Sun Microsystems Solaris, Linux, Mach, Windows NT, Windows 2000, Windows XP, Windows Vista, DEC VMS, IBM OS/2, Apple Mac OS X, precum si in cazul altor sisteme de operare. 

# Planificarea proceselor    
Planificarea procesorului este una din indatoririle de baza ale unui sistem de operare.   Planificarea cu succes a procesorului este derivata din observatia ca fiecare proces contine un ciclu format din executii de procesor si momente de asteptare I/O. Algoritmii de planificare a procesorului au proprietati diferite si acestia pot favoriza o anumita clasa de procese fata de altele.   

- **Primul venit, Primul servit (Fierst Come, Fierst Served)**   
    Cel mai simplu algoritm de planificare, acesta da procesorul, procesului care a facut primul cererea. Daca unui proces i se aloca procesorul acesta il pastreaza ocupat pana se termina sau pana cand acesta solita o operatie I/O. Utilizand acest algoritm se produce efectul de convoi, un proces mare tinand ocupat procesorul pentru foarte mult timp, restul proceselor fiind nevoite sa stea in asteptare.   

- **Slujba cea mai mica are prioritate (Shortest Job Fierst)**   
    Acest algoritm asociaza fiecarui proces durata urmatorului tact de procesor. Cand procesorul este disponibil, acesta este dat procesului care are nevoie de cel mai putin timp de executie. Algoritmul are in vedere de cat are nevoie sa se execute un proces la urmatoarea alocare a procesorului, nu lungimea totala a procesului.  Adevarata problema cu care se confrunta SJF este aceea  de a determina de cat timp va avea nevoie un proces la urmatoarea executie. De obicei pentru aceasta valoare se face o predictie in functie de durata medie a executiilor precedente ale procesului.
- **Planificarea Round-Robin**   
    Acest algoritm de planificare este destinat in special pentru sisteme menite sa functioneze cu timp impartit al procesorului. O mica unitate de timp, numita quanta de timp, este definita. Coada de asteptare ready este privita ca o coada circulara. Planificatorul se misca dea lungul cozii, alocand procesorul fiecarui proces pentru un interval de cel putin o quanta de timp.


# Gestiunea proceselor      
Un proces poate fi privit ca un program in executie. El va avea nevoie de anumite resurse, cum sunt: timpii de procesor, memorie, fisiere si intreruperi I/O pentru a-si indeplini scopul.   

Procesul este unitatea functionala a majoritatii sistemelor. Sistemul de operare este responsabil cu managementul proceselor : crearea si stergerea proceselor utilizator sau de sistem, programarea lor pentru executie, mecanisme de sincronizare, de comunicare intre ele precum si de alocare resurselor comune utilizate de catre procese.    

In cadrul executiei unui proces acesta trece prin mai multe etape : new  (procesul este creat), running (instructiunile procesului sunt executate), waiting (se asteapta producerea unui eveniment, intrerupere I/O sau receptionarea unui semnal), ready (procesul asteapta sa fie executat de procesor) si terminated (procesul isi termina executia). 

Un proces cand nu se afla in executie este plasat intr-o coada de asteptare. Cele mai importante doua cozi de asteptare ale unui sistem de operare sunt coada I/O si coada ready. Coada ready contine toate procesele care sunt pregatite pentru executie si asteapta procesorul.

Planificarea pe termen lung este cea care selecteaza procesele (le pune in coada ready) si care le permite acestora sa fie executate de catre procesor. In mod normal planificarea pe termen lung este influentata de considerente legate de alocarea resurselor si in special de managementul memoriei.

Planificatorul pe termen scurt alege un proces din coada de asteptare ready. Procesele pot fi executate concurent de catre sistem. Exista cateva motive pentru care este permisa executia concurenta a proceselor: partajarea  de informatii, marirea vitezei de lucru, modularizare si inlesnirea functionarii. 

# Sincronizarea proceselor    
Un proces cooperativ este un proces care poate afecta, sau care este afectat de executia altui proces. Procesele cooperative pot schimba informatii fie prin zone comune de memorie (care cuprind atat cod cat si date) sau prin fisiere. Accesarea concurenta a informatiilor partajate poate duce la pierderea consistentei datelor.   
Fiecare proces are un segment de cod numit sectiune critica, in care procesul poate schimba variabile comune. Aspectul cel mai important este ca atunci cand un proces executa sectiunea critica, nici unui alt proces nu trebuie sa i se permita sa execute sectiunea sa critica. O solutie pentru sectiunea critica trebuie sa indeplineasca urmatoarele trei conditii:   
- **Algoritmul Brutarului** - Rezolvarea problemei sectiunii critice pentru n procese poarta denumirea de algoritmul brutarului. Are la baza algoritmul folosit in brutarii pentru servirea clientilor. La intrarea in magazin, fiecare client primeste un numar. Clientul cu numarul cel mai mic este servit intai.  
- **Problema Scriitori-Cititori** - Un obiect urmeaza sa fie partajat de mai multe procese. Unele procese doresc doar sa citeasca continutul obiectului partajat, in timp ce altele doresc si sa-l modifice. Distingem astfel doua tipuri de procese, cititorii sunt procesele care sunt interesate doar de citirea continutului procesului partajat si scriitori interesati sa modifice obiectul. Pentru a ne asigura ca nu apar dificultati, trebuie ca scriitorii sa aiba acces exclusiv asupra obiectului partajat.    
- **Problema Cinei Filozofilor** - Se considera cinci filozofi care isi petrec viata gandind si mancand. Acestia impart o masa rotunda si cinci scaune, cate un scaun pentru fiecare.  in centrul mesei se afla un bol cu orez iar concentric ei, sunt dispuse cinci betisoare. Din timp in timp, unui filozof i se face foame si incearca sa ridice cele mai apropiate doua betisoare de el. Un filozof poate ridica un singur betisor odata. Cand un filozof are ambele betisoare acesta poate manca. Dupa ce termina de mancat acesta pune betisoarele jos si incepe sa gandeasca din nou.    
- **Problema Barbierului Adormit** -  intr-o frizerie avem un barbier, un scaun pentru barbierit si n scaune de asteptare. Daca nici un client nu este prezent, barbierul doarme in scaunul de barbierit. Cand un client soseste, el va trezi barbierul. Daca un client soseste si barbierul este ocupat, fie asteapta, fie pleaca. 

# Administrarea memoriei    
De obicei memoria este separata in doua parti: una pentru sistemul de operare si una pentru procesele utilizator. Cand planificatorul procesorului selecteaza un proces pentru a fi executat iar acesta nu exista in memorie este nevoie ca acesta sa fie alocat. Una din metodele cele mai usoare de alocare a memoriei este ca aceasta sa fie impartita in cateva zone de marime fixa numite partitii. Fiecare partitie poate contine exact un proces. Sistemul de operare va tine un tabel cu partile de memorie disponibile si cu partile de memorie ocupate. Cand un proces soseste si necesita memorie se cauta o zona libera suficient de mare pentru proces. Daca sau gasit mai multe zone in care procesul incape, selectia acestora se face cu unul din algoritmii:

- **First Fit** - Se aloca prima zona de memorie care este suficient de mare. Cautarea poate incepe fie de la prima zona libera de memorie fie de la locul in care sa facut ultima alocare. Cautarea se incheie de indata ce o zona suficient de mare a fost gasita.   
- **Best Fit** - Se aloca zona cea mai mica libera care este suficient de mare pentru ca procesul sa incapa. Trebuie cautata intreaga lista daca aceasta nu este ordonata dupa marime. Aceasta strategie duce la obtinerea celor mai mici zone de memorie care nu mai pot fi folosite.   
- **Worst Fit** - Alocarea se face in zona cea mai mare de memorie libera gasita.  Din nou trebuie cercetata intreaga lista daca aceasta nu este ordonata. Avantajul acestui model este ca zonele de memorie nefolosibile se obtin doar la incarcarea puternica a sistemului.    

Dupa ce un proces a fost alocat, acesta poate fi incarcat  in memorie si poate fi executat de catre procesor. Cand un proces se termina, el va elibera memoria, iar sistemul de operare poate sa o umple cu un alt proces din coada de asteptare.   

Pe masura ce procesele sunt aduse si scoase din memorie, spatiul liber de memorie este fragmentat in bucati mici. Acest tip de fragmentare poarta denumirea de fragmentare externa. Depinzand de cantitatea totala de memorie si de media marimilor proceselor, fragmentarea externa poate fi o problema majora.  in cazul algoritmului fierst fit se ajunge deseori ca o treime din intreaga memorie sa nu poata fi utilizata. O solutie pentru aceasta problema o reprezinta compactarea. Cel mai simplu algoritm de compactare este mutarea tuturor proceselor unul dupa altul, astfel la final obtinandu-se o singura zona mare de memorie disponibila.    

# Paginarea la cerere    
Pentru ca executia unui program sa fie posibila, acesta trebuie sa fie incarcat de pe disc in memorie. O posibilitate este aceea de a incarca intregul program in memoria fizica. O problema a acestei abordari o reprezinta faptul caci intreg programul nu este necesar inca de la inceput. O strategie alternativa  este aceea de a incarca paginile doar atunci cand este nevoie de ele. Aceasta tehnica poarta denumirea de paginare la cerere si este des folosita in sistemele care implementeaza memoria virtuala.  

Cand un proces trebuie sa fie adus in memorie, algoritmul ghiceste ce pagini vor fi necesare si le aduce in memorie.  in loc sa aduca intreg procesul, sunt aduse doar paginile necesare, astfel paginile care nu sunt folosite, nu sunt aduse niciodata, aceasta abordare ducand la un timp de mutare mai mic si la o folosire mai optima a memoriei fizice.   

- **Algoritmul de schimbare a paginilor Primul Venit  Primul Iesit (FIFO)**   
Acesta este cel mai simplu algoritm de inlocuire a paginilor, fiind sacrificata pagina cea mai veche si inlocuita cu o pagina noua. Algoritmul nu necesita masurarea timpului de viata pentru fiecare pagina, putandu-se utiliza o coada FIFO care sa memoreze toate paginile. Astfel se va  elimina pagina din capul listei si se va adauga noua pagina la coada listei. Algoritmul este usor de inteles si implementat, dar performantele sale sunt reduse. Pe de o parte pagina inlocuita poate fi un modul de initializare al procesului, dar pe de alta parte poate contine si o variabila intens si continuu folosita.  inlocuirea unei pagini intens folosite va duce la o noua eroare de paginare, o noua pagina va trebui inlocuita, astfel putandu-se ajunge la un lant de erori.   
- **Algoritmul de schimbare a paginii cel mai indepartat folosite (LRU)**   
    Ideea algoritmului este ca in loc sa prezicem care pagina va fi folosita, vom vedea care pagina a fost folosita cel mai des. LRU  asociaza fiecarei pagini timpul ultime ei utilizari.  Cand o pagina trebuie inlocuita se va alege pagina care nu a fost folosita pentru cea mai lunga perioada de timp. Astfel, algoritmul LRU, priveste in trecut si nu in viitor. Rezultatele obtinute de algoritm sunt bune, insa problema principala cu care acesta se confrunta este modul in care acesta poate fi implementat. Algoritmul LRU necesita suport puternic din partea hardwar-ului. Problema consta in a determina o ordine pentru pagini in functie de ultima data cand acestea au fost folosite.    


# Metode de alocare a spatiului pe disc    
In majoritatea cazurilor multe fisiere sunt salvate pe acelasi disc. Principala problema este cum sa se aloce spatiu pentru aceste fisiere, astfel incat utilizarea discului sa fie eficienta si accesul la fisiere sa fie rapid.

- **Alocarea continua**   
    Acest tip de alocare presupune ca fiecare fisier sa ocupe  o zona continua de blocuri pe disc. Adresele discului definesc o ordine liniara. Numarul cautarilor pentru alocarea unui fisier este minim, la fel si pentru cautarea lui. Alocarea continua a unui fisier este definita de o adresa pe disc unde incepe fisierul si de lungimea lui. Accesarea unui fisier care a fost alocat continuu este usoara si facila insa problemele cu care se confrunta aceasta alocare sunt numeroase. Gasirea spatiului liber pentru un fisier nou este o problema majora. Astfel se foloseste unul din algoritmi First Fit sau Best Fit discutati anterior. Dupa cum am vazut deja acesti algoritmi sufera de fragmentare externa, care poate deveni o problema serioasa a sistemului de operare. O alta problema care apare la folosirea alocarii continue este aceea ca nu tot timpul se cunoaste de la inceput spatiul necesar unui fisier. Chiar daca totusi alocarea sa facut cu succes exista posibilitatea ca dimensiunea fisierului sa se modifice la o folosire ulterioara, ceea ce ar duce din nou la probleme grave.   
- **Alocarea inlantuita**   
    Alocarea inlantuita rezolva toate problemele cu care se confrunta alocarea continua. Astfel fiecare fisier este o lista inlantuita de blocuri de pe disc, aceste blocuri putandu-se afla oriunde pe disc. Se vor memora pentru un fisier doar un pointer la blocurile de inceput si final ale fisierului. Fiecare bloc va memora un pointer catre urmatorul bloc. Exista insa si dezavantaje, astfel o parte din disc este folosita pentru a memora pointeri care leaga blocurile. Un alt dezavantaj al alocarii inlantuite il reprezinta accesarea unui anumit bloc dintr-un fisier. Astfel pentru a se ajunge la un anumit bloc este necesar ca toata lista de blocuri pana la locatia respectiva sa fie parcursa. 

# Planificarea discului   
O responsabilitate a sistemului de operare este aceea de a folosi discul eficient.  in cazul discului aceasta inseamna un timp de acces rapid si un transfer de informatii cat mai mare. Atat timpul de acces cat si viteza de transfer pot fi imbunatatite printr-o planificare buna a cererilor I/O care se fac spre disc.  in cazul  sistemelor cu multe procese coada de asteptare pentru disc are deseori  numeroase cereri. Ordinea in care aceste cereri sunt rezolvate este foarte importanta si exista mai multi algoritmi folositi pentru determinarea acestei ordini   
- **Primul Sosit Primul Servit** - Este cel mai simplu algoritm dar nu ofera rezultate bune. Deseori se produc deplasari pe distante foarte mari ale capului de citire.   Prioritate pentru timpul de cautare cel mai redus - Acesta serveste intai cererile cele mai apropiate de zona in care se afla. El va selecta cererea cea mai apropiata de pozitia sa curenta. O problema a acestui algoritm o reprezinta  infometarea cererilor. Daca o cerere este foarte indepartata de zona in care se afla capul de citire si exista numeroase cereri in apropierea cereri curente, cererea indepartata va fi servita cu o intarziere mare.   
- Algoritmul **SCAN** -  in cazul acestui algoritm, bratul de citire porneste de la un capat al discului si se misca spre celalalt capat, servind cererile pe care le intalneste pe parcurs, pana cand ajunge in celalalt capat. Ajuns la celalalt capat, bratul de citire isi schimba directia pana ajunge din nou la inceputul discului. Algoritmul mai poarta denumirea de algoritmul liftului, deoarece bratul de citire se misca ca un lift, intai servind toate cererile mergand in sus, apoi toate cererile mergand in jos. Algoritmul nu este foarte eficient, deoarece daca apar cereri in zona in care tocmai sa fost citirea, va fi nevoie sa se astepte doua parcurgeri ale discului, pentru ca cererea sa fie rezolvata.    
- Algoritmul **C-SCAN** - Reprezinta o versiune imbunatatita a algoritmului SCAN. Bratul de citire se misca de la inceputul discului spre finalul lui, dar cand ajunge aici se  deplaseaza la inceputul discului fara a servi  vreo cerere pe parcurs. Algoritmul trateaza discul ca o lista circulara si il parcurge de la primul cilindru pana la ultimul.    
- Algoritmul **LOOK** - Este asemanator cu algoritmul SCAN, doar ca bratul se misca doar pana la ultima cerere iar apoi isi schimba directia de deplasare. Dupa schimbarea directiei, se va parcurge din nou discul pana la ultima cerere dupa care se va intoarce. Exista si C-LOOK care, dupa ce ajunge la ultima cerere dintr-o directie de deplasare, sare la prima cerere din directia cealalta de deplasare. 

